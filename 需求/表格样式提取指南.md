# 从 styles.xml 提取表格格式所需片段

## 重要说明

**`w:type="table"` 的 `w:style` 可以有多个！**

一个 docx 文档中通常会有多个表格样式定义，例如：
- 默认表格样式（如 "Normal Table"）
- 预定义表格样式（如 "Table Grid"、"Table Simple 1"、"Table Classic 1" 等）
- 用户自定义的表格样式

每个表格可以应用不同的样式，因此需要提取**所有** `w:type="table"` 的样式定义，而不仅仅是默认样式。

## 默认表格样式 vs 自定义表格样式

### 区别对比

| 特性 | 默认表格样式 | 自定义表格样式 |
|------|-------------|---------------|
| **标识** | 有 `w:default="1"` 属性 | 没有 `w:default` 属性 |
| **styleId** | 通常是 `"6"` 或数字ID | 可以是任意字符串（如 "TableGrid"、"MyCustomTable"） |
| **名称** | 通常是 "Normal Table" | 可以是任意名称 |
| **用途** | 当表格没有指定样式时使用 | 需要显式引用才能使用 |
| **必需性** | **必须保留**（否则表格可能无法正确显示） | 按需提取（只提取文档中实际使用的） |
| **定义位置** | 在 `styles.xml` 中明确定义 | 在 `styles.xml` 中定义，或在 `latentStyles` 中预定义 |

### 如何识别默认表格样式

**XML 特征**：
```xml
<w:style w:type="table" w:default="1" w:styleId="6">
  <w:name w:val="Normal Table"/>
  <!-- ... -->
</w:style>
```

**识别方法**：
- 查找 `w:default="1"` 属性
- 或者查找 `w:styleId="6"`（最常见的默认表格样式ID）
- 或者查找名称为 "Normal Table" 的表格样式

### 如何识别自定义表格样式

**XML 特征**：
```xml
<w:style w:type="table" w:styleId="TableGrid">
  <w:name w:val="Table Grid"/>
  <!-- ... -->
</w:style>
```

**识别方法**：
- 没有 `w:default="1"` 属性
- `w:styleId` 通常是描述性名称（如 "TableGrid"、"TableSimple1" 等）
- 在 `document.xml` 中通过 `<w:tblStyle w:val="样式ID"/>` 显式引用

### 实际应用场景

#### 场景一：表格没有指定样式
```xml
<!-- document.xml -->
<w:tbl>
  <w:tblPr>
    <!-- 没有 <w:tblStyle> 元素 -->
  </w:tblPr>
  <!-- ... -->
</w:tbl>
```
**结果**：使用默认表格样式（`w:default="1"` 的样式）

#### 场景二：表格指定了自定义样式
```xml
<!-- document.xml -->
<w:tbl>
  <w:tblPr>
    <w:tblStyle w:val="TableGrid"/>  <!-- 显式指定样式 -->
  </w:tblPr>
  <!-- ... -->
</w:tbl>
```
**结果**：使用 "TableGrid" 样式（需要在 `styles.xml` 中找到对应的样式定义）

### 提取策略建议

1. **默认样式（必须提取）**：
   ```python
   # 查找默认表格样式
   default_table_style = styles_tree.xpath(
       '//w:style[@w:type="table" and @w:default="1"]',
       namespaces=namespaces
   )
   ```

2. **自定义样式（按需提取）**：
   ```python
   # 从 document.xml 中找出所有使用的样式ID
   used_style_ids = set()
   for table in tables:
       style_id = table.xpath('.//w:tblPr/w:tblStyle/@w:val', namespaces=namespaces)
       if style_id:
           used_style_ids.add(style_id[0])
   
   # 只提取实际使用的自定义样式
   for style_id in used_style_ids:
       custom_style = styles_tree.xpath(
           f'//w:style[@w:type="table" and @w:styleId="{style_id}"]',
           namespaces=namespaces
       )
   ```

### 注意事项

1. **默认样式是必需的**：即使文档中所有表格都指定了自定义样式，默认样式也必须保留，因为：
   - 某些表格可能没有显式指定样式
   - Word 在处理表格时可能需要回退到默认样式
   - 样式继承链可能依赖默认样式

2. **样式继承**：自定义样式可能通过 `w:basedOn` 继承自默认样式：
   ```xml
   <w:style w:type="table" w:styleId="TableGrid">
     <w:basedOn w:val="6"/>  <!-- 继承自默认样式 -->
     <!-- ... -->
   </w:style>
   ```
   这种情况下，默认样式和自定义样式都需要提取。

3. **完整提取建议**：
   - ✅ 提取所有默认表格样式（`w:default="1"`）
   - ✅ 提取文档中实际使用的自定义样式
   - ✅ 提取自定义样式继承的基础样式（递归查找 `w:basedOn`）
   - ❌ 不需要提取未使用的自定义样式（除非要保留完整的样式库）

## 核心需要提取的内容

### 1. **表格样式定义** (`w:type="table"`)

**需要提取所有** `w:type="table"` 的 `<w:style>` 元素（可能有多个），包括：

```xml
<w:style w:type="table" w:styleId="样式ID">
  <w:name w:val="样式名称"/>
  <w:basedOn w:val="基础样式"/>  <!-- 可选，需要递归查找 -->
  <w:tblPr>
    <!-- 表格属性 -->
    <w:tblBorders>
      <!-- 边框定义 -->
      <w:top w:val="边框类型" w:sz="粗细" w:space="间距" w:color="颜色"/>
      <w:left w:val="..." />
      <w:bottom w:val="..." />
      <w:right w:val="..." />
      <w:insideH w:val="..." />  <!-- 内部水平边框 -->
      <w:insideV w:val="..." />  <!-- 内部垂直边框 -->
    </w:tblBorders>
    <w:tblCellMar>
      <!-- 单元格边距 -->
      <w:top w:w="数值" w:type="dxa"/>
      <w:left w:w="数值" w:type="dxa"/>
      <w:bottom w:w="数值" w:type="dxa"/>
      <w:right w:w="数值" w:type="dxa"/>
    </w:tblCellMar>
    <w:tblInd w:w="数值" w:type="dxa"/>  <!-- 表格缩进 -->
    <w:jc w:val="对齐方式"/>  <!-- 表格对齐 -->
    <w:tblCellSpacing w:w="数值" w:type="dxa"/>  <!-- 单元格间距 -->
    <w:tblLayout w:type="auto|fixed"/>  <!-- 表格布局 -->
    <w:tblW w:w="数值" w:type="auto|dxa|pct"/>  <!-- 表格宽度 -->
  </w:tblPr>
  <w:rPr>
    <!-- 表格内文本的字符格式 -->
    <w:rFonts w:ascii="字体" w:hAnsi="字体" w:eastAsia="字体"/>
    <w:sz w:val="字号"/>
    <w:color w:val="颜色"/>
    <!-- 其他字符格式属性 -->
  </w:rPr>
  <w:pPr>
    <!-- 表格内段落的格式 -->
    <w:jc w:val="对齐方式"/>
    <w:spacing w:before="数值" w:after="数值"/>
    <!-- 其他段落格式属性 -->
  </w:pPr>
  <w:tblStylePr w:type="firstRow|lastRow|firstCol|lastCol|band1Vert|band2Vert|band1Horz|band2Horz|neCell|nwCell|seCell|swCell">
    <!-- 特殊行/列的样式（如首行、末行、首列等） -->
    <w:rPr>...</w:rPr>
    <w:pPr>...</w:pPr>
    <w:tblPr>...</w:tblPr>
  </w:tblStylePr>
</w:style>
```

### 2. **表格单元格样式** (`w:type="tableCell"`)

如果存在单元格样式定义：

```xml
<w:style w:type="tableCell" w:styleId="样式ID">
  <w:name w:val="样式名称"/>
  <w:basedOn w:val="基础样式"/>
  <w:tcPr>
    <!-- 单元格属性 -->
    <w:tcBorders>...</w:tcBorders>
    <w:shd w:fill="填充色" w:val="clear|solid"/>
    <w:vAlign w:val="top|center|bottom"/>
  </w:tcPr>
</w:style>
```

### 3. **相关的段落和字符样式**

表格内文本可能引用的段落样式 (`w:type="paragraph"`) 和字符样式 (`w:type="character"`)，需要根据 `document.xml` 中的实际引用情况提取。

### 4. **默认样式** (`w:docDefaults`)

文档默认样式，可能影响表格格式：

```xml
<w:docDefaults>
  <w:rPrDefault>
    <w:rPr>
      <!-- 默认字符格式 -->
    </w:rPr>
  </w:rPrDefault>
  <w:pPrDefault>
    <!-- 默认段落格式 -->
  </w:pPrDefault>
</w:docDefaults>
```

## 提取策略

### 方法一：完整提取（推荐）

1. **提取所有表格样式**：查找所有 `w:type="table"` 的样式
2. **提取样式继承链**：对于有 `w:basedOn` 的样式，递归查找基础样式
3. **提取相关段落/字符样式**：根据 `document.xml` 中表格实际使用的样式ID提取
4. **保留命名空间声明**：保留 `<w:styles>` 根元素的命名空间声明

### 方法二：按需提取

1. 先解析 `document.xml`，找出所有表格及其引用的样式ID
2. 只提取这些样式ID对应的样式定义
3. 递归提取这些样式的 `w:basedOn` 基础样式

## 关键元素说明

| 元素 | 作用 | 是否必需 |
|------|------|---------|
| `w:tblBorders` | 定义表格边框（上下左右及内部边框） | **必需** |
| `w:tblCellMar` | 定义单元格边距 | **必需** |
| `w:tblStylePr` | 定义特殊行/列的样式（如首行加粗、斑马纹等） | 可选但重要 |
| `w:rPr` | 表格内文本的字符格式 | 推荐 |
| `w:pPr` | 表格内段落的格式 | 推荐 |
| `w:shd` | 单元格背景色/填充 | 重要 |
| `w:vAlign` | 单元格垂直对齐 | 重要 |

## 注意事项

1. **样式继承**：如果样式有 `w:basedOn` 属性，需要同时提取基础样式
2. **命名空间**：必须保留完整的命名空间声明，否则XML解析会失败
3. **默认表格样式**：`w:styleId="6"` 或 `w:default="1"` 的表格样式通常是默认样式，必须保留
4. **特殊样式**：`w:tblStylePr` 定义了表格的特殊行/列样式，对保持格式很重要

## 示例：从您的 styles.xml 中需要提取的片段

基于您当前的 styles.xml，至少需要提取：

```xml
<!-- 默认表格样式（必须保留） -->
<w:style w:type="table" w:default="1" w:styleId="6">
  <w:name w:val="Normal Table"/>
  <w:semiHidden/>
  <w:qFormat/>
  <w:uiPriority w:val="0"/>
  <w:tblPr>
    <w:tblCellMar>
      <w:top w:w="0" w:type="dxa"/>
      <w:left w:w="108" w:type="dxa"/>
      <w:bottom w:w="0" w:type="dxa"/>
      <w:right w:w="108" w:type="dxa"/>
    </w:tblCellMar>
  </w:tblPr>
</w:style>

<!-- 可能还有其他表格样式，例如： -->
<!-- <w:style w:type="table" w:styleId="TableGrid">...</w:style> -->
<!-- <w:style w:type="table" w:styleId="TableSimple1">...</w:style> -->
<!-- 等等... -->
```

**重要**：需要提取**所有** `w:type="table"` 的样式，而不仅仅是默认样式。如果文档中使用了多个表格样式，每个样式都需要提取。

## 如何查找所有表格样式

使用 XPath 或正则表达式查找所有表格样式：

**XPath 查询**：
```xpath
//w:style[@w:type='table']
```

**正则表达式**（用于文本搜索）：
```regex
<w:style[^>]*w:type="table"[^>]*>.*?</w:style>
```

**Python 示例**（使用 lxml）：
```python
from lxml import etree

tree = etree.parse('styles.xml')
namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
table_styles = tree.xpath('//w:style[@w:type="table"]', namespaces=namespaces)
print(f"找到 {len(table_styles)} 个表格样式")
```

## 如何查看表格使用的样式

表格使用的样式定义在 `word/document.xml` 文件中。每个表格（`<w:tbl>`）的样式通过 `<w:tblStyle>` 元素引用。

### 在 document.xml 中的结构

```xml
<w:tbl>
  <w:tblPr>
    <!-- 表格属性 -->
    <w:tblStyle w:val="样式ID"/>  <!-- 这里指定了表格使用的样式 -->
    <!-- 其他表格属性 -->
  </w:tblPr>
  <!-- 表格行和单元格 -->
</w:tbl>
```

### 查找方法

#### 方法一：XPath 查询

**查找所有表格及其样式**：
```xpath
//w:tbl/w:tblPr/w:tblStyle/@w:val
```

**查找特定表格的样式**（例如第一个表格）：
```xpath
(//w:tbl)[1]/w:tblPr/w:tblStyle/@w:val
```

#### 方法二：Python 代码示例

```python
from lxml import etree

# 解析 document.xml
doc_tree = etree.parse('word/document.xml')
namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}

# 查找所有表格
tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)

for i, table in enumerate(tables, 1):
    # 查找表格样式
    tbl_style = table.xpath('.//w:tblPr/w:tblStyle/@w:val', namespaces=namespaces)
    
    if tbl_style:
        style_id = tbl_style[0]
        print(f"表格 {i} 使用的样式ID: {style_id}")
    else:
        print(f"表格 {i} 没有指定样式（使用默认样式）")
```

#### 方法三：使用正则表达式

在 `document.xml` 中搜索：
```regex
<w:tblStyle w:val="([^"]+)"/>
```

### 注意事项

1. **没有样式引用**：如果表格的 `<w:tblPr>` 中没有 `<w:tblStyle>` 元素，则使用默认表格样式（通常是 `styleId="6"` 或 `w:default="1"` 的样式）。

2. **样式ID 对应关系**：
   - `document.xml` 中的 `w:val` 值 = `styles.xml` 中的 `w:styleId` 值
   - 例如：`<w:tblStyle w:val="TableGrid"/>` 对应 `<w:style w:styleId="TableGrid" w:type="table">`

3. **完整查找流程**：
   ```
   document.xml → 找到 <w:tblStyle w:val="样式ID"/>
   ↓
   styles.xml → 找到 <w:style w:styleId="样式ID" w:type="table">
   ↓
   提取该样式的完整定义
   ```

### 完整示例：提取表格及其样式

```python
from lxml import etree
from zipfile import ZipFile

def extract_table_styles(docx_path):
    """从 docx 文件中提取所有表格及其使用的样式"""
    
    with ZipFile(docx_path, 'r') as docx:
        # 读取 document.xml
        doc_xml = docx.read('word/document.xml')
        doc_tree = etree.fromstring(doc_xml)
        
        # 读取 styles.xml
        styles_xml = docx.read('word/styles.xml')
        styles_tree = etree.fromstring(styles_xml)
    
    namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    
    # 查找所有表格
    tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)
    
    result = []
    for i, table in enumerate(tables, 1):
        # 获取样式ID
        tbl_style = table.xpath('.//w:tblPr/w:tblStyle/@w:val', namespaces=namespaces)
        style_id = tbl_style[0] if tbl_style else None
        
        if not style_id:
            # 查找默认表格样式
            default_style = styles_tree.xpath(
                '//w:style[@w:type="table" and @w:default="1"]/@w:styleId',
                namespaces=namespaces
            )
            style_id = default_style[0] if default_style else "6"
        
        # 在 styles.xml 中查找样式定义
        style_def = styles_tree.xpath(
            f'//w:style[@w:type="table" and @w:styleId="{style_id}"]',
            namespaces=namespaces
        )
        
        result.append({
            'table_index': i,
            'style_id': style_id,
            'style_definition': etree.tostring(style_def[0]).decode() if style_def else None
        })
    
    return result

# 使用示例
# tables = extract_table_styles('example.docx')
# for table in tables:
#     print(f"表格 {table['table_index']} 使用样式: {table['style_id']}")
```

## 根据表格查找对应样式（完整流程）

这是一个完整的流程，从 `document.xml` 中的表格元素找到它在 `styles.xml` 中对应的样式定义。

### 流程图

```
表格元素 (<w:tbl>)
    ↓
查找 <w:tblPr>/<w:tblStyle w:val="样式ID"/>
    ↓
有样式引用？
    ├─ 是 → 使用指定的样式ID
    └─ 否 → 使用默认表格样式（w:default="1"）
    ↓
在 styles.xml 中查找 <w:style w:styleId="样式ID" w:type="table">
    ↓
找到样式定义
    ↓
检查是否有 w:basedOn（样式继承）
    ↓
递归查找基础样式（如果需要）
    ↓
返回完整的样式定义
```

### 完整代码实现

```python
from lxml import etree
from zipfile import ZipFile

def find_table_style(docx_path, table_index=1):
    """
    根据表格索引查找对应的样式定义
    
    参数:
        docx_path: docx文件路径
        table_index: 表格索引（从1开始）
    
    返回:
        dict: 包含样式ID和样式定义的字典
    """
    
    namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    
    with ZipFile(docx_path, 'r') as docx:
        # 读取 document.xml
        doc_xml = docx.read('word/document.xml')
        doc_tree = etree.fromstring(doc_xml)
        
        # 读取 styles.xml
        styles_xml = docx.read('word/styles.xml')
        styles_tree = etree.fromstring(styles_xml)
    
    # 步骤1: 找到指定的表格
    tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)
    
    if table_index < 1 or table_index > len(tables):
        raise ValueError(f"表格索引 {table_index} 超出范围（共 {len(tables)} 个表格）")
    
    target_table = tables[table_index - 1]
    
    # 步骤2: 查找表格的样式引用
    tbl_style_ref = target_table.xpath('.//w:tblPr/w:tblStyle/@w:val', namespaces=namespaces)
    
    if tbl_style_ref:
        # 有显式样式引用
        style_id = tbl_style_ref[0]
        print(f"表格 {table_index} 使用样式: {style_id}")
    else:
        # 没有样式引用，使用默认样式
        default_style = styles_tree.xpath(
            '//w:style[@w:type="table" and @w:default="1"]/@w:styleId',
            namespaces=namespaces
        )
        style_id = default_style[0] if default_style else "6"
        print(f"表格 {table_index} 没有指定样式，使用默认样式: {style_id}")
    
    # 步骤3: 在 styles.xml 中查找样式定义
    style_def = styles_tree.xpath(
        f'//w:style[@w:type="table" and @w:styleId="{style_id}"]',
        namespaces=namespaces
    )
    
    if not style_def:
        raise ValueError(f"未找到样式ID为 '{style_id}' 的表格样式定义")
    
    # 步骤4: 检查样式继承
    based_on = style_def[0].xpath('.//w:basedOn/@w:val', namespaces=namespaces)
    base_styles = []
    
    if based_on:
        base_style_id = based_on[0]
        print(f"样式 '{style_id}' 继承自: {base_style_id}")
        # 递归查找基础样式
        base_style = styles_tree.xpath(
            f'//w:style[@w:type="table" and @w:styleId="{base_style_id}"]',
            namespaces=namespaces
        )
        if base_style:
            base_styles.append({
                'style_id': base_style_id,
                'definition': etree.tostring(base_style[0]).decode()
            })
    
    return {
        'table_index': table_index,
        'style_id': style_id,
        'style_definition': etree.tostring(style_def[0]).decode(),
        'base_styles': base_styles,
        'is_default': not bool(tbl_style_ref)
    }


def find_all_table_styles(docx_path):
    """
    查找文档中所有表格及其对应的样式
    
    返回:
        list: 每个表格的样式信息列表
    """
    
    namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    
    with ZipFile(docx_path, 'r') as docx:
        doc_xml = docx.read('word/document.xml')
        doc_tree = etree.fromstring(doc_xml)
        
        styles_xml = docx.read('word/styles.xml')
        styles_tree = etree.fromstring(styles_xml)
    
    # 查找所有表格
    tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)
    
    # 查找默认样式ID
    default_style = styles_tree.xpath(
        '//w:style[@w:type="table" and @w:default="1"]/@w:styleId',
        namespaces=namespaces
    )
    default_style_id = default_style[0] if default_style else "6"
    
    results = []
    
    for i, table in enumerate(tables, 1):
        # 查找样式引用
        tbl_style_ref = table.xpath('.//w:tblPr/w:tblStyle/@w:val', namespaces=namespaces)
        
        if tbl_style_ref:
            style_id = tbl_style_ref[0]
        else:
            style_id = default_style_id
        
        # 查找样式定义
        style_def = styles_tree.xpath(
            f'//w:style[@w:type="table" and @w:styleId="{style_id}"]',
            namespaces=namespaces
        )
        
        if style_def:
            results.append({
                'table_index': i,
                'style_id': style_id,
                'style_name': style_def[0].xpath('.//w:name/@w:val', namespaces=namespaces)[0] if style_def[0].xpath('.//w:name/@w:val', namespaces=namespaces) else None,
                'is_default': not bool(tbl_style_ref),
                'style_definition': etree.tostring(style_def[0]).decode()
            })
        else:
            results.append({
                'table_index': i,
                'style_id': style_id,
                'style_name': None,
                'is_default': not bool(tbl_style_ref),
                'style_definition': None,
                'error': f"未找到样式定义"
            })
    
    return results


# 使用示例
if __name__ == "__main__":
    # 示例1: 查找第一个表格的样式
    result = find_table_style('example.docx', table_index=1)
    print(f"样式ID: {result['style_id']}")
    print(f"是否默认样式: {result['is_default']}")
    
    # 示例2: 查找所有表格的样式
    all_results = find_all_table_styles('example.docx')
    for result in all_results:
        print(f"表格 {result['table_index']}: 样式ID={result['style_id']}, "
              f"样式名称={result['style_name']}, "
              f"默认样式={result['is_default']}")
```

### 简化版本（快速查找）

```python
def get_table_style_id(table_element, styles_tree, namespaces):
    """
    快速获取表格的样式ID
    
    参数:
        table_element: 表格的XML元素
        styles_tree: styles.xml的解析树
        namespaces: XML命名空间字典
    
    返回:
        str: 样式ID
    """
    # 查找样式引用
    style_ref = table_element.xpath('.//w:tblPr/w:tblStyle/@w:val', namespaces=namespaces)
    
    if style_ref:
        return style_ref[0]
    
    # 没有引用，返回默认样式ID
    default = styles_tree.xpath(
        '//w:style[@w:type="table" and @w:default="1"]/@w:styleId',
        namespaces=namespaces
    )
    return default[0] if default else "6"


def get_style_definition(style_id, styles_tree, namespaces):
    """
    根据样式ID获取样式定义
    
    参数:
        style_id: 样式ID
        styles_tree: styles.xml的解析树
        namespaces: XML命名空间字典
    
    返回:
        Element: 样式定义的XML元素，如果未找到则返回None
    """
    style_def = styles_tree.xpath(
        f'//w:style[@w:type="table" and @w:styleId="{style_id}"]',
        namespaces=namespaces
    )
    return style_def[0] if style_def else None


# 使用示例
namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}

# 假设已经解析了 document.xml 和 styles.xml
tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)

for i, table in enumerate(tables, 1):
    # 获取样式ID
    style_id = get_table_style_id(table, styles_tree, namespaces)
    
    # 获取样式定义
    style_def = get_style_definition(style_id, styles_tree, namespaces)
    
    if style_def:
        print(f"表格 {i} 使用样式: {style_id}")
        # 可以进一步处理样式定义
    else:
        print(f"表格 {i} 的样式 '{style_id}' 未找到定义")
```

### 关键步骤总结

1. **定位表格**：在 `document.xml` 中找到目标表格元素 `<w:tbl>`
2. **查找样式引用**：在 `<w:tblPr>/<w:tblStyle w:val="..."/>` 中查找样式ID
3. **处理默认情况**：如果没有样式引用，使用默认表格样式（`w:default="1"`）
4. **查找样式定义**：在 `styles.xml` 中根据样式ID查找对应的 `<w:style>` 元素
5. **处理样式继承**：如果样式有 `w:basedOn`，递归查找基础样式

### 常见问题

**Q: 如果表格没有 `<w:tblStyle>` 元素怎么办？**  
A: 使用默认表格样式（查找 `w:default="1"` 的表格样式）

**Q: 如果样式ID在 styles.xml 中找不到怎么办？**  
A: 可能是样式定义缺失，需要检查文档完整性，或者样式可能在 `latentStyles` 中定义

**Q: 如何处理样式继承？**  
A: 递归查找 `w:basedOn` 指向的基础样式，直到找到所有依赖的样式定义

## 创建新 docx 文件并装入表格和样式

提取表格XML和样式XML后，需要创建一个新的docx文件并将它们装入。docx文件实际上是一个ZIP压缩包，包含多个XML文件。

### docx 文件结构

```
example.docx (ZIP文件)
├── [Content_Types].xml          # 内容类型定义
├── _rels/
│   └── .rels                     # 主关系文件
├── word/
│   ├── document.xml              # 文档内容（包含表格）
│   ├── styles.xml                # 样式定义
│   ├── _rels/
│   │   └── document.xml.rels     # 文档关系文件
│   └── theme/
│       └── theme1.xml             # 主题文件（可选）
└── docProps/
    ├── app.xml                    # 应用属性
    └── core.xml                   # 核心属性
```

### 完整实现代码

```python
from lxml import etree
from zipfile import ZipFile, ZIP_DEFLATED
from io import BytesIO
import os
from datetime import datetime

def create_docx_with_tables(tables_xml_list, styles_xml, output_path):
    """
    创建新的docx文件，包含表格和样式
    
    参数:
        tables_xml_list: 表格XML元素列表（从原文档提取的 <w:tbl> 元素）
        styles_xml: 样式XML字符串或元素（完整的 styles.xml 内容）
        output_path: 输出文件路径
    """
    
    # 创建临时内存中的ZIP文件
    zip_buffer = BytesIO()
    
    with ZipFile(zip_buffer, 'w', ZIP_DEFLATED) as docx:
        # 1. 创建 [Content_Types].xml
        content_types = create_content_types()
        docx.writestr('[Content_Types].xml', content_types)
        
        # 2. 创建主关系文件
        main_rels = create_main_rels()
        docx.writestr('_rels/.rels', main_rels)
        
        # 3. 创建 word/document.xml（包含表格）
        document_xml = create_document_xml(tables_xml_list)
        docx.writestr('word/document.xml', document_xml)
        
        # 4. 创建 word/styles.xml
        if isinstance(styles_xml, str):
            styles_content = styles_xml
        else:
            styles_content = etree.tostring(styles_xml, encoding='utf-8', xml_declaration=True).decode('utf-8')
        docx.writestr('word/styles.xml', styles_content)
        
        # 5. 创建 word/_rels/document.xml.rels
        doc_rels = create_document_rels()
        docx.writestr('word/_rels/document.xml.rels', doc_rels)
        
        # 6. 创建 docProps/core.xml
        core_xml = create_core_xml()
        docx.writestr('docProps/core.xml', core_xml)
        
        # 7. 创建 docProps/app.xml
        app_xml = create_app_xml()
        docx.writestr('docProps/app.xml', app_xml)
    
    # 将内存中的ZIP文件写入磁盘
    zip_buffer.seek(0)
    with open(output_path, 'wb') as f:
        f.write(zip_buffer.getvalue())


def create_content_types():
    """创建 [Content_Types].xml"""
    return '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
    <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>'''


def create_main_rels():
    """创建主关系文件 _rels/.rels"""
    return '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
    <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
    <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>'''


def create_document_xml(tables_xml_list):
    """
    创建 word/document.xml，包含表格
    
    参数:
        tables_xml_list: 表格XML元素列表
    """
    namespaces = {
        'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
        'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
    }
    
    # 创建文档根元素
    document = etree.Element('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}document',
                            nsmap=namespaces)
    
    # 创建 body 元素
    body = etree.SubElement(document, '{http://schemas.openxmlformats.org/wordprocessingml/2006/main}body')
    
    # 添加每个表格
    for table_xml in tables_xml_list:
        # 如果 table_xml 是字符串，先解析
        if isinstance(table_xml, str):
            table_elem = etree.fromstring(table_xml)
        else:
            table_elem = table_xml
        
        # 将表格添加到 body
        body.append(table_elem)
    
    # 转换为XML字符串
    xml_str = etree.tostring(document, encoding='utf-8', xml_declaration=True, pretty_print=True).decode('utf-8')
    return xml_str


def create_document_rels():
    """创建 word/_rels/document.xml.rels"""
    return '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>'''


def create_core_xml():
    """创建 docProps/core.xml"""
    now = datetime.now().strftime('%Y-%m-%dT%H:%M:%SZ')
    return f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:dcterms="http://purl.org/dc/terms/"
    xmlns:dcmitype="http://purl.org/dc/dcmitype/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <dc:title>Extracted Tables</dc:title>
    <dc:creator>Table Extractor</dc:creator>
    <cp:lastModifiedBy>Table Extractor</cp:lastModifiedBy>
    <cp:revision>1</cp:revision>
    <dcterms:created xsi:type="dcterms:W3CDTF">{now}</dcterms:created>
    <dcterms:modified xsi:type="dcterms:W3CDTF">{now}</dcterms:modified>
</cp:coreProperties>'''


def create_app_xml():
    """创建 docProps/app.xml"""
    return '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"
    xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
    <Application>Microsoft Office Word</Application>
    <AppVersion>16.0000</AppVersion>
</Properties>'''


# ========== 使用示例 ==========

def extract_and_create_docx(source_docx_path, output_docx_path, table_indices=None):
    """
    从源docx文件中提取表格和样式，创建新的docx文件
    
    参数:
        source_docx_path: 源docx文件路径
        output_docx_path: 输出docx文件路径
        table_indices: 要提取的表格索引列表（从1开始），None表示提取所有表格
    """
    
    namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    
    with ZipFile(source_docx_path, 'r') as source_docx:
        # 读取 document.xml
        doc_xml = source_docx.read('word/document.xml')
        doc_tree = etree.fromstring(doc_xml)
        
        # 读取 styles.xml
        styles_xml = source_docx.read('word/styles.xml')
        styles_tree = etree.fromstring(styles_xml)
    
    # 提取所有表格
    all_tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)
    
    if table_indices is None:
        # 提取所有表格
        selected_tables = all_tables
    else:
        # 提取指定索引的表格
        selected_tables = [all_tables[i-1] for i in table_indices if 1 <= i <= len(all_tables)]
    
    # 提取表格使用的样式（包括默认样式和自定义样式）
    used_style_ids = set()
    
    # 查找默认表格样式
    default_style = styles_tree.xpath(
        '//w:style[@w:type="table" and @w:default="1"]',
        namespaces=namespaces
    )
    if default_style:
        used_style_ids.add(default_style[0].get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId'))
    
    # 查找表格使用的样式
    for table in selected_tables:
        tbl_style = table.xpath('.//w:tblPr/w:tblStyle/@w:val', namespaces=namespaces)
        if tbl_style:
            used_style_ids.add(tbl_style[0])
    
    # 提取使用的样式定义
    extracted_styles = []
    
    # 提取默认样式
    if default_style:
        extracted_styles.append(default_style[0])
    
    # 提取自定义样式
    for style_id in used_style_ids:
        if style_id not in [s.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId') 
                           for s in extracted_styles]:
            style_def = styles_tree.xpath(
                f'//w:style[@w:type="table" and @w:styleId="{style_id}"]',
                namespaces=namespaces
            )
            if style_def:
                extracted_styles.append(style_def[0])
    
    # 构建新的 styles.xml
    # 保留原有的命名空间和结构
    new_styles_root = etree.Element('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styles',
                                    nsmap=styles_tree.getroot().nsmap)
    
    # 复制 docDefaults（文档默认样式）
    doc_defaults = styles_tree.xpath('//w:docDefaults', namespaces=namespaces)
    if doc_defaults:
        new_styles_root.append(doc_defaults[0])
    
    # 复制 latentStyles（如果需要）
    latent_styles = styles_tree.xpath('//w:latentStyles', namespaces=namespaces)
    if latent_styles:
        new_styles_root.append(latent_styles[0])
    
    # 添加提取的表格样式
    for style in extracted_styles:
        new_styles_root.append(style)
    
    # 添加必要的默认样式（Normal段落样式等）
    necessary_styles = styles_tree.xpath(
        '//w:style[@w:type="paragraph" and @w:default="1"] | '
        '//w:style[@w:type="character" and @w:default="1"]',
        namespaces=namespaces
    )
    for style in necessary_styles:
        # 检查是否已存在
        style_id = style.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId')
        existing = new_styles_root.xpath(f'.//w:style[@w:styleId="{style_id}"]', namespaces=namespaces)
        if not existing:
            new_styles_root.append(style)
    
    # 转换为XML字符串
    styles_xml_str = etree.tostring(new_styles_root, encoding='utf-8', xml_declaration=True, pretty_print=True).decode('utf-8')
    
    # 创建新的docx文件
    create_docx_with_tables(selected_tables, styles_xml_str, output_docx_path)
    
    print(f"成功创建新docx文件: {output_docx_path}")
    print(f"包含 {len(selected_tables)} 个表格")
    print(f"包含 {len(extracted_styles)} 个表格样式")


# ========== 使用示例 ==========

if __name__ == "__main__":
    # 示例1: 提取所有表格
    extract_and_create_docx('source.docx', 'output_all_tables.docx')
    
    # 示例2: 只提取前两个表格
    extract_and_create_docx('source.docx', 'output_first_two.docx', table_indices=[1, 2])
    
    # 示例3: 手动提取表格和样式，然后创建新文件
    with ZipFile('source.docx', 'r') as docx:
        doc_xml = docx.read('word/document.xml')
        doc_tree = etree.fromstring(doc_xml)
        styles_xml = docx.read('word/styles.xml')
    
    namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)
    
    # 创建新文件
    create_docx_with_tables(tables[:2], styles_xml, 'output_manual.docx')
```

### 简化版本（快速使用）

```python
def quick_extract_tables_to_docx(source_path, output_path, table_indices=None):
    """
    快速提取表格到新docx文件
    
    参数:
        source_path: 源docx文件路径
        output_path: 输出docx文件路径
        table_indices: 表格索引列表，None表示所有表格
    """
    from lxml import etree
    from zipfile import ZipFile
    from io import BytesIO
    
    namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    
    # 读取源文件
    with ZipFile(source_path, 'r') as source:
        doc_tree = etree.fromstring(source.read('word/document.xml'))
        styles_xml = source.read('word/styles.xml')
    
    # 提取表格
    all_tables = doc_tree.xpath('//w:tbl', namespaces=namespaces)
    
    if table_indices:
        tables = [all_tables[i-1] for i in table_indices if 1 <= i <= len(all_tables)]
    else:
        tables = all_tables
    
    # 创建新docx
    extract_and_create_docx(source_path, output_path, 
                            table_indices=[i+1 for i in range(len(tables))] if table_indices else None)
```

### 注意事项

1. **样式完整性**：
   - 必须包含默认表格样式（`w:default="1"`）
   - 必须包含表格实际使用的所有自定义样式
   - 建议包含必要的段落和字符默认样式

2. **样式继承**：
   - 如果自定义样式有 `w:basedOn`，需要同时提取基础样式
   - 建议递归提取所有依赖的样式

3. **命名空间**：
   - 确保所有XML文件使用正确的命名空间
   - 保持与原文档的命名空间一致

4. **文件结构**：
   - docx是ZIP格式，必须包含所有必需的文件
   - `[Content_Types].xml` 和关系文件（`_rels`）是必需的

5. **测试建议**：
   - 创建后用Word打开检查格式是否正确
   - 验证表格样式是否完整保留
   - 检查是否有样式引用错误

